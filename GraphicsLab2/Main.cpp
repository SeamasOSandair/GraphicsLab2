//------------------------------------------------------------------------------------
// File main.cpp
//
// Author: Dr. Shane Wilson, Ulster University
//
// Date: 24/01/2017
//
// Description: This lab demonstrates how to create an 
// empy windos application using Win32. The basic steps required are:
// 
//  1. Define and register the windows class
//  2. Create the windows object
//  3. Handle event messages to and from the window
//
//-------------------------------------------------------------------------------------
#include "stdafx.h"

//Global variables

//* Direct 3D 12 global variables
bool Running = true;
const int  frameBufferCount = 2; // number of buffers we want, 2 for double buffering, 3 for triple buffering
ID3D12Device* device; // direct3d device
IDXGISwapChain3* swapChain; // swapchain used to switch between render targets
ID3D12CommandQueue* commandQueue; //container for command lists
ID3D12DescriptorHeap* rtvDescriptorHeap; // a descriptor heap to hold resources like the render targets
ID3D12Resource* renderTargets[frameBufferCount]; // number of render targets equal to buffer count
ID3D12CommandAllocator* commandAllocator[frameBufferCount]; // we want enough allocators for each buffer * number of threads, (we only have one)
ID3D12GraphicsCommandList* commandList; // a command list we can record commands
ID3D12Fence* fence[frameBufferCount]; // an object that is locked while our command list is being executed by the gpu. We need as many as we have allocators (more if we wnat to know when the gpu is finished with an asset)

HANDLE fenceEvent; // a handle to an event when our fence is unlocked by the gpu
UINT64 fenceValue[frameBufferCount]; // this value is incremented each frame, each frame will have it's own value
int frameIndex; //currently rtv we are on
int rtvDescriptorSize; // size of the rtv descriptor on the device (all front and back buffer will be the same size)

// function declarations
bool InitD3D(); //initialises Direct 3D 12
void Update(); // update the game logic
void UpdatePipeline(); // update the direct3d pipepline (update command lists)
void Render(); // execute the command list
void CleanUp(); // release com objects and clean up memory
void WaitForPreviousFrame(); // wait until gpu is finished with command lists

// Handle to the window
HWND hwnd = NULL;

// name of the window (not the title)
LPCTSTR WindowName = L"Lab2App";

// title of the window
LPCTSTR WindowTitle = L"COM428 LAB 2";

// width and height of the window
int Width = 800;
int Height = 600;

// is window full screen?
bool FullScreen = false;

//
#define SAFE_RELEASE(p){ if ((p)) { (p)->Release(); (p) = 0;}}

//Forward declarations

// create a window
bool InitializeWindow(HINSTANCE hInstance, int ShowWnd,	int width, int height,bool fullscreen);
// Main application loop
void Mainloop();
// callback function for windows messages
LRESULT CALLBACK WndProc(HWND hWnd,	UINT msg, WPARAM wParam,	LPARAM lParam);

//Application entry point
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR lpCmdLine, int nShowCmd)
{
	//hInstance - The application's instance generated by windows
	//hPrevInstance - The applications previous instance (deprecated)
	//lpCmdLine - String containing application parameters
	//nShowCmd - Value controlling the manner in which the application launches

	// create the window
	if (!InitializeWindow(hInstance, nShowCmd, Width, Height, FullScreen))
	{
		MessageBox(0, L"Window Initialization - Failed",
			L"Error", MB_OK);
		return 0;
	}

	// initialise Direct 3D
	if (!InitD3D())
	{
		MessageBox(0, L"Failed to initialise Direct3D 12", L"Error", MB_OK);
		CleanUp();
		return 1;
	}

	// start the main loop
	Mainloop();

	// we want to wait for the GPU to finish with the command list before we start releasing everything
	WaitForPreviousFrame();

	// close the fence event
	CloseHandle(fenceEvent);

	return 0;
}

bool InitializeWindow(HINSTANCE hInstance, int ShowWnd, int width, int height, bool fullscreen)
{
	//Check to see if we want to go full screen
	if (fullscreen)
	{
		HMONITOR hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
		MONITORINFO mi = { sizeof(mi) };
		GetMonitorInfo(hmon, &mi);

		width = mi.rcMonitor.right - mi.rcMonitor.left;
		height = mi.rcMonitor.bottom - mi.rcMonitor.top;
	}


	//First we need to define a windows class information using a WNDCLASSEX structure
	WNDCLASSEX wc;

	wc.cbSize = sizeof(WNDCLASSEX); //The size of the structure
	wc.style = CS_HREDRAW | CS_VREDRAW; //Specify the style of the window (CS_HREDRAW and CS_VREDRAW specify the window must be redrawn when resized horizontally or vertically
	wc.lpfnWndProc = WndProc; //Specifies the callback function that will process event messages
	wc.cbClsExtra = NULL; //Specifies the number of bytes to be allocated to store extra class information
	wc.cbWndExtra = NULL; //Specifies the number of bytes to be allocated to store extra windows information
	wc.hInstance = hInstance; //a handle to the instance of the application
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION); //App icon
	wc.hCursor = LoadCursor(NULL, IDC_ARROW); //The windows cursor
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 2); //The colour value for the background colour of the window
	wc.lpszMenuName = NULL; //String specifying the resource name for the windows menu
	wc.lpszClassName = WindowName; //The name of the windows class
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION); //The small icon used by the class.

	//Attempt to register the class
	if (!RegisterClassEx(&wc))
	{
		MessageBox(NULL, L"Error registering class",
			L"Error", MB_OK | MB_ICONERROR);
		return false;
	}

	//Create the window with the class we registered
	hwnd = CreateWindowEx(NULL,
		WindowName, //The name of the windows class (as above)
		WindowTitle, //The windows caption 
		WS_OVERLAPPEDWINDOW, //Style of the window
		CW_USEDEFAULT, CW_USEDEFAULT, //X & Y coordinates window spawn location on screen
		width, height, //Window width height 
		NULL, //Handle to the parent window
		NULL, //Handle to the menu or child window
		hInstance, //Handle to the application instance
		NULL); //Window creation data. Not required


	//If we didn't get a windows handle show an error message
	if (!hwnd)
	{
		MessageBox(NULL, L"Error creating window",
			L"Error", MB_OK | MB_ICONERROR);
		return false;
	}

	//Otherwise go full screen if 
	if (fullscreen)
	{
		SetWindowLong(hwnd, GWL_STYLE, 0);
	}

	//Show the window
	ShowWindow(hwnd, ShowWnd);
	UpdateWindow(hwnd);

	return true;
}//End InitializeWindow

//Main loop
void Mainloop() {
	MSG msg;
	ZeroMemory(&msg, sizeof(MSG));

	while (true)
	{
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			if (msg.message == WM_QUIT)
				break;

			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else {
			// run game code
		}
	}
}//End MainLoop

LRESULT CALLBACK WndProc(HWND hwnd,	UINT msg, WPARAM wParam,LPARAM lParam)
{
	//WndProc is the callback function used to process windows messages

	switch (msg)
	{

	case WM_KEYDOWN:
		if (wParam == VK_ESCAPE) {
			if (MessageBox(0, L"Are you sure you want to exit?",
				L"Really?", MB_YESNO | MB_ICONQUESTION) == IDYES)
				DestroyWindow(hwnd);
		}
		return 0;

	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	}
	return DefWindowProc(hwnd, msg, wParam, lParam);
}

bool InitD3D()
{
	//Out Initialise D3D function does the following:
	//1. Create a D3D device which we use to access the GPU
	//2. Define and create our swap chain
	//3. Create the render target descriptor heap
	//4. Create our render target view
	//5. Create our depth/stencil buffer & view

	HRESULT hr;

	//--Create The Device--//
	//IDXGIFactory is an interface for creating DirectX Graphics Infrastructure (DXGI objects)
	IDXGIFactory4* dxgiFactory;
	hr = CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory));
	if (FAILED(hr)) 
	{
		return false;
	}

	IDXGIAdapter1* adapter; // adapters are the graphics card, this includes the embedded graphics card on the motherboard
	int adapterIndex = 0; // We'll start looking at DirectX 12 compatible devices starting at index 0
	bool adapterFound = false; // set this to true when a good one was found

	//first we find the hardware GPU that supports D3D 12
	while (dxgiFactory->EnumAdapters1(adapterIndex, &adapter) != DXGI_ERROR_NOT_FOUND)
	{
		DXGI_ADAPTER_DESC1 desc;
		adapter->GetDesc1(&desc);

		if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE)
		{
			//We don't want a software device
			adapterIndex++; // add this line here, it is not currently in the downloadable project
			continue;
		}

		// we want a device that is compatable with direct 3d 11 (feature level 11 or higher)
		hr = D3D12CreateDevice(adapter, D3D_FEATURE_LEVEL_11_0, _uuidof(ID3D12Device), nullptr);
		if (SUCCEEDED(hr))
		{
			adapterFound = true;
			break;
		}

		adapterIndex++;
	}

	if (!adapterFound)
	{
		return false;
	}

	//So if we get this far we have an adapter that supports featue level 11.0 (DX12) so lets create the device
	hr = D3D12CreateDevice(
		adapter, // the adapter we wabnt to create
		D3D_FEATURE_LEVEL_11_0, //Min feature level our application requires support for
		IID_PPV_ARGS(&device) // The COM ID of the ID3D12Device interface we want to create
	);
	if (FAILED(hr))
	{
		return false;
	}

	//Now we have a D3D 12 device lets create the Command Queue for our device
	//We will use command Queue to execute command lists which contain commands for the GPU

	D3D12_COMMAND_QUEUE_DESC cqDesc = {}; // we will be using all the default values
	hr = device->CreateCommandQueue(&cqDesc, IID_PPV_ARGS(&commandQueue)); // create the command queue
	if (FAILED(hr))
	{
		return false;
	}

	// -- Create the Swap Chain (double/triple buffering -- //

	DXGI_MODE_DESC backBufferDesc = {}; // This is to describe our  display mode
	backBufferDesc.Width = Width; // buffer width
	backBufferDesc.Height = Height; // buffer height
	backBufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // Format of the buffer (rgba 32 bits, 8 bits for each channel)

	//descirbe our multi-sampling. We are not multisampling, so we set it to one as we need at least one sample
	DXGI_SAMPLE_DESC sampleDesc = {};
	sampleDesc.Count = 1; // multi-sampling count, we are not multi-sampling but we still need 1 sample

	DXGI_SWAP_CHAIN_DESC swapChainDesc = {}; 
	swapChainDesc.BufferDesc.Width = Width; //Buffer Width
	swapChainDesc.BufferDesc.Height = Height; //Buffer Height
	swapChainDesc.BufferDesc.RefreshRate.Numerator = 60; // Refresh rate in hz
	swapChainDesc.BufferDesc.RefreshRate.Denominator = 1;
	swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // Format of the buffer (rgba 32 bit, 8 for each channel
	swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED; // The method the raster uses to create an image upon the surface
	swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED; // How an image is stretcged to fit a given monitor's resolution
	swapChainDesc.SampleDesc.Count = 1; // The number of multisamples
	swapChainDesc.SampleDesc.Quality = 0; // Multisampling quality
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; // Use resource  as an output render target
	swapChainDesc.BufferCount = frameBufferCount; // 2 for front and back buffer (double buffering)
	swapChainDesc.OutputWindow = hwnd; // handle to our window
	swapChainDesc.Windowed = !FullScreen; //set to true, then if in FullScreen, must call SetFullScreenState with true for fullscreen to get uncapped fps
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD; // dxgi will discard the buffer data after we call present
	swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH; // Allow swtich between windowed and fullscreen

	IDXGISwapChain* tempSwapChain;

	dxgiFactory->CreateSwapChain(
		commandQueue, //the queue will be flushed once the swap chain is created
		&swapChainDesc, // give it the swap chain description we created above
		&tempSwapChain //store the created swap chain in a temp IDXGISwapChain interface
	);

	swapChain = static_cast<IDXGISwapChain3*>(tempSwapChain);

	frameIndex = swapChain->GetCurrentBackBufferIndex();

	//Create the Render Targte Heap
	// We need a heap for each typr of render target
	//We have 2 types Rneder Target Views (rtv's) and Stencil Target Views (stv'c)

	//describe an RTV Desciptor heap and create
	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = {};
	rtvHeapDesc.NumDescriptors = frameBufferCount; // number of descriptors for this heap
	rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; // This heap is a render target view heap

	//This heap will not be directly refernced by the shaders (not shader visible), as this will store output from the pipleline
	// otherwise we would get the heap's flag to D3D12_DESCRIPTO_HEAP_FLAG_SHADER_VISIBLE
	rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	hr = device->CreateDescriptorHeap(&rtvHeapDesc, IID_PPV_ARGS(&rtvDescriptorHeap));
	if (FAILED(hr))
	{
		return false;
	}

	// get the size of a descriptor in this heap (this is a rtv heap, so only rtv descriptors should be stored in it)
	// descriptor sizes may vary from device to device, which is why there is no set size, and why we must ask the device to give us the size.
	// We will use this size to implement a descriptor handle offset
	rtvDescriptorSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

	// get a handle to the first descriptor in the descriptor heap. A handle is basically a pointer, but we cannot literally use it like a c++ pointer
	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(rtvDescriptorHeap->GetCPUDescriptorHandleForHeapStart());

	//Create a rtv for each buffer (double buffering is 2 buffers, triple buffering is 3)
	for (int i = 0; frameBufferCount; i++)
	{
		//first we  get the n'th buffer in the swap chain and store it in the n'th position in the ID3D12Resouce array
		hr = swapChain->GetBuffer(i, IID_PPV_ARGS(&renderTargets[i]));
		if (FAILED(hr))
		{
			return false;
		}

		// then we "create" a render target view which binds the swap chain buffer (ID3D12Resource[n]) to the rtv handle
		device->CreateRenderTargetView(renderTargets[i], nullptr, rtvHandle);

		//We increment the rtv handle by the rtv descriptor size we got above
		rtvHandle.Offset(1, rtvDescriptorSize);
	}

	//Create The command Allocators
	//The command allocator is used to allocate memory on the GPU for the commands we want to execute by calling execute from the command queue and providing a command list with the commands we want to execute
	// -- Create The Command Allocators -- //

	for (int i = 0; i < frameBufferCount; i++)
	{
		hr = device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocator[i]));
		if (FAILED(hr))
		{
			return false;
		}
	}

	//Create the command list
	//One command list for each thread. We are using 1 thread
	// create the command list with the first allocator
	hr = device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator[0], NULL, IID_PPV_ARGS(&commandList));
	if (FAILED(hr))
	{
		return false;
	}

	// command lists are created in the  recording state. Our main loop will set it up for recording again so close it for now
	commandList->Close();

	//Create a Fence and FenceEvent
	//We are only using thread, so we only need one fence event, but since we are double buffering we have 2 fences, one for easch buffer

	//Create the Fences
	for (int i = 0; i < frameBufferCount; i++)
	{
		hr = device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence[i]));
		if (FAILED(hr))
		{
			return false;
		}
		fenceValue[i] = 0; // set the initial fence value to 0
	}

	//create a handle to the fence event
	fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);
	if (fenceEvent = nullptr)
	{
		return false;
	}

	return true;
}//End InitD3D

void Update()
{
	// Update app logic, such as moving the camera otr figuring out which objects are in view
}

void UpdatePipeline()
{
	HRESULT hr;

	/* This function is where we will add commands to the command list., 
	which include the changing the state of the render target, setting the root signature and clearing the render target.
	Later we will be setting vertex buffers and calling draw in this function
	*/

	//We have to wait for the GPU to finish the command allocator before we reset it
	WaitForPreviousFrame();

	// we can only reset an allocator once the GPU is done with it
	// resetting an allocator frees up the memory the command lists was stored in
	hr = commandAllocator[frameIndex]->Reset();
	if (FAILED(hr))
	{
		Running = false;
	}

	//reset the command list, by resetting the command list we are putting it into a recording state so that we can start recording command into the command allocator
	//the command allocator that we refernce here may have multiple command lists associated with it, but only one can be recording at any time.
	// Make sure that nay other command lists associated with this allocator are in the closed state (not recording).
	//Here you will pass an initial pipeline stateobject as the second parameter, but in this tutorial we are only clearing the rtv
	// and do not actualy need anything except for a default pipeline, which is what we get by setting the second paramater to NULL
	hr = commandList->Reset(commandAllocator[frameIndex], NULL);
	if (FAILED(hr))
	{
		Running = false;
	}

	//here we start recording commands into the commandList, (which all the commands will be stored in the Command Allocator)
	
	//transition the "frameIndex" render target from the present state to the render target state, so the command List draws to it starting from here
	commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex], D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

	//here again we get the handle to our render target view, so we can set it as the render target in the output merger of the pipeline
	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(rtvDescriptorHeap->GetCPUDescriptorHandleForHeapStart(), frameIndex, rtvDescriptorSize);

	//set the render target for the output merger state (the output of the pipeline)
	commandList->OMSetRenderTargets(1, &rtvHandle, FALSE, nullptr);

	//Clear the render targets by using the ClearRenderTargetsView command
	const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
	commandList->ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);

	//transition the "frameIndex" render target from the render target state to the present state. If the debug layer is enabled, you'll receive a warning if present is called on the render target when it is not is the presetn state
	commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex], D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

	hr = commandList->Close();
	if (FAILED(hr))
	{
		Running = false;
	}

}

void Render()
{
	HRESULT hr;

	UpdatePipeline(); // Update the pipeline by sending commands to the command queue
	
	//Create an array of command lists (only one command list here
	ID3D12CommandList* ppCommandLists[] = { commandList };

	//execute the array of command lists
	commandQueue->ExecuteCommandLists(_countof(ppCommandLists), ppCommandLists);

	//This command goes in at the end of the command queue, we know when the command queue has finished becasue the fence value will be set to "fenceValue"
	//from the GPU since the command queue is being executed by the GPU
	hr = commandQueue->Signal(fence[frameIndex], fenceValue[frameIndex]);
	if (FAILED(hr))
	{
		Running = false;
	}

	//present the current back buffer
	hr = swapChain->Present(0, 0);
	if (FAILED(hr))
	{
		Running = false;
	}

}

void CleanUp()
{
	//Wait for the GPU to finish all frames
	for (int i = 0; i < frameBufferCount; i++)
	{
		frameIndex = i;
		WaitForPreviousFrame();
	}

	//get the swapChain out of FullScreen before exiting
	BOOL fs = false;
	if (swapChain->GetFullscreenState(&fs, NULL))
		swapChain->GetFullscreenState(false, NULL);
	{
		SAFE_RELEASE(device);

	}
	
}
